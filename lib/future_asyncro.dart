//конспект учебного видео Евгения Елчева
// статья "Работа с асинхронностью в Dart"
// https://habr.com/ru/company/surfstudio/blog/539362/ 



// теория 
/*многопоточность - это два действия делать одновременно, асинхронность - не ждать 
 результат чего-то, если мы можем не ждать. то есть выполнить когда-то потом, код какой-то,
 не сейчас
 потом: когда будет получена информация из сети (делается не нашей программой, а ОС),
 когда будет открыт файл (также делается не нашей программой, а ОС)
 ждать смысла нет, лучще вернуться к обработке по завершению

 асинхронность - это возможность выполнить функцию за два раза: начать, бросить, а потом продолжить
 */

/*
поток можно представить как человек, который готовит на кухне
я - поток, я могу выполнять одновременно только одно действие


я хочу налить чай

1 вариант - без future
алгоритм:
взять кружку;
поставить кружку;
положить чайный пакетик;
насыпать сахар;
поставить чайник вскипать;
подождать когда вскипит;
залить кипятком;
    (пока я беру кружку, я не могу сделать ничего другого.
    пока я кладу пакетик с чаем, тоже я не могу сделать ничего другого.
    пока я сыплю сахар - других действий я делать не могу
    )
 
 2 вариант - с future
действия те же, но когда мы ставим чайник, я отхожу от него, не жду. и начинаю
делать бутерброт.
чайник закипает без меня, я делаю бутер. скорее всего даже раньше чем закипит чайник.
дождался чайник. и все действия закончились. я свободен. я поток, я свободен.
могу сесть на стул, отдохнуть, чтобы не тратить ресурс!)))

есть и 3 вариант
когда я еще начал пылесосить.
чайник щелкнул - вскипел, но я занят уборкой. только когда Я убрался я могу налить чай 
 */

/*

void main(List<String> arguments) {
  // print(1);
  // //поставили чайник !!!
  // var result = File("C:/dart/futur.txt").readAsString();
  // print(2);
  // //когда чайник закипит, выведим на печать полученное значение
  // result.then((value) => print(value));
//сначала отработают принты, затем выполнится код result.then((value) => print(value));



//        некоторые методы

//у класса Future метод then используется часто
// когда результат будет готов, с ним можно выполнить какое-либо действие

// метод whenComplete(() => null)
// похож на then
// когда фьючер будет готов, то можно выполнить действие, но значение не залетает в кол-бэк
  // result.whenComplete(() => null);

  final f1 = Future.delayed(Duration(seconds: 2));
  f1.whenComplete(() => print(1));
  final f2 = Future.delayed(Duration(seconds: 5));
  f2.whenComplete(() => print(2));

  //Future.wait([f1, f2]);   wait ждет завершения нескольких фьюч
  final f3 = Future.wait([f1, f2]);
  f3.then((value) => print('f3'));
}

 */

/*
void main(List<String> arguments) {
  final a = sum(1, 4);
  a.then((a) {
    print(a);
    final b = sum(a, 9);
    b.then((b) {
      print(b);
      final c = sum(a, b);
      c.then((value) => print(value));
    });
  });
}
*/

/*
Future<int> sum(int a, int b) {
  return Future.sync(() => a + b);
  // .sync - берет обычную синхронную операцию и возвращает future
  
}

Future<void> example() async {
  final a = await sum(1, 4);
  print(a);
  final b = await sum(a, 9);
  print(b);
  final c = await sum(a, b);
  print(c);
}

void main(List<String> arguments) async {
  // первый вариант с помощью then
  /*
  Работать с Future через обработчики then и catchError — не самая хорошая идея, 
  особенно если нужно передать результат одного Future во второй, 
  а второго в третий и т. д., порождая callback hell.
  https://habr.com/ru/company/surfstudio/blog/539362/
   */
  //final a = sum(1, 4);
  // a.then((a) {
  //   print(a);
  //   final b = sum(a, 9);
  //   b.then((b) {
  //     print(b);
  //     final c = sum(a, b);
  //     c.then((value) => print(value));
  //   });
  // });

//второй вариант с помощью async/await
/*
при таком подходе мы теряем обработчик catchError, 
однако никто не мешает нам обрабатывать ошибки через стандартный try/catch.
статья "Работа с асинхронностью в Dart"
https://habr.com/ru/company/surfstudio/blog/539362/ 
*/

  // print('start');
  // final a = await sum(1, 4);
  // print(a);
  // final b = await sum(a, 9);
  // print(b);
  // final c = await sum(a, b);
  // print(c);
  // print('end');

  /*
  здесь операции выполняются последовательно (синхронно): т.е.  с помощью слова 
  await мы ждем выполнение операции и только потом выполнятся последущие операции
  это необходимо тогда когда нам нужно дождаться результата, чтобы использовать его
  в последующей операции

  на печать выведится
start
5
14
19
end

*/
        а здесь мы не ждем 
  // print('start');
  // example(); без async await поток не ждет выполнения этой операции, а "готовит бутер пока закипает чайник", 
  // то есть другие нижиследующие операции
  // print('end');
  // после первого принта ('start'), запускается выполнение функции example
  //так как эта функция асинхронная, то поток не задерживается, поток пустой и выполнятся принт print('end');
  // и когда готов результ работы функции example, отображается 5 14 19
  start
  end
  5
  14
  19

}
*/




/*

void main(List<String> args) async {
  print('start');
  final a = await sum(1, 4);
  print('другие операции');
  print('другие операции');
  print('другие операции');
  print(a);
  final b = await sum(a, 9);
  print(b);
  final c = await sum(a, b);
  print(c);
  print('end');
}
хотя компилятор ждет результата выполнения, но при этом поток свободный
и может выполнять другую работу

start
другие операции
другие операции
другие операции
5
14
19
end


*/